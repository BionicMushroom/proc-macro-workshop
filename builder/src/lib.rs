//! Provides the [`Builder`] derive macro.

use proc_macro::TokenStream;
use quote::{format_ident, quote, ToTokens};
use std::collections::HashSet;
use syn::{
    parse_macro_input, spanned::Spanned, Data, DataStruct, DeriveInput, Error, Field, Fields,
    GenericArgument, Ident, LitStr, Meta, Path, PathArguments, Type, Visibility,
};

/// A derive macro that generates the boilerplate code involved in
/// implementing the builder pattern in Rust. Builders are a mechanism
/// for instantiating structs, especially structs with many fields,
/// and especially if many of those fields are optional or the set of
/// fields may need to grow backward compatibly over time.
///
/// # Example
///
/// ```
/// use derive_builder::Builder;
///
/// #[derive(Builder)]
/// pub struct Command {
///     executable: String,
///     #[builder(each = "arg")]
///     args: Vec<String>,
///     current_dir: Option<String>,
/// }
///
/// let command = Command::builder()
///     .executable("cargo".to_owned())
///     .arg("build".to_owned())
///     .arg("--release".to_owned())
///     .build()
///     .unwrap();
///
/// assert_eq!(command.executable, "cargo");
/// assert_eq!(command.args, vec!["build", "--release"]);
/// assert_eq!(command.current_dir, None);
/// ```
///
/// # Generated code
///
/// More generally, let's talk about what code is generated by
/// deriving [`Builder`] on a struct called `Example`.
///
/// ## Methods on the struct on which `Builder` is derived
///
/// The `builder() -> ExampleBuilder` method is generated on the
/// `Example` struct.
///
/// ## The `ExampleBuilder` struct
///
/// The `ExampleBuilder` struct has setter methods for each of
/// the fields present in the `Example` struct, generated according
/// to the following rules:
/// * if we have a field `field_name: Option<T>`, then the method
///   `field_name(&mut ExampleBuilder, field_name: T) -> &mut ExampleBuilder`
///   is generated. If this method is not called, the
///   [`Option`](https://doc.rust-lang.org/std/option/enum.Option.html)
///   remains [`None`](https://doc.rust-lang.org/std/option/enum.Option.html#variant.None);
/// * if we have a field `field_name: Vec<T>` marked with the
///   `builder(each = "setter_name")` attribute, then the method
///   `setter_name(&mut ExampleBuilder, setter_name: T) -> &mut ExampleBuilder`
///   is generated. It can be used to append values to the
///   [`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html),
///   one a time. If `setter_name` does not conflict with `field_name`, then the method
///   `field_name(&mut ExampleBuilder, field_name: Vec<T>) -> &mut ExampleBuilder`
///   is also generated. It can be used to set all the values in the
///   [`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html), all at once,
///   overwriting any existing values. If neither of these two methods are called, the
///   [`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html) stays empty;
/// * otherwise, if we have a field `field_name: T`, then the method
///   `field_name(&mut ExampleBuilder, field_name: T) -> &mut ExampleBuilder`
///   is generated. If this method is not called, an error will be returned
///   from the `build()` method.
///
/// A `build(&mut ExampleBuilder) -> Result<Example, ExampleBuilderErr>` is
/// also generated. As stated above, it will return an error if any
/// required setter was not called.
///
/// ## The `ExampleBuilderErr` struct
///
/// The `ExampleBuilderErr` struct has a `msg(&ExampleBuilderErr) -> &str`
/// method that can help in debugging what went wrong when building the
/// `Example` struct. The `ExampleBuilderErr` struct also implements
/// the [`Error`](https://doc.rust-lang.org/std/error/trait.Error.html) trait.
///
/// # Notes on visibility
///
/// The following items have the same visibility as the struct on which
/// [`Builder`] is derived:
/// * the builder struct itself;
/// * the builder setter methods;
/// * the `build` method on the builder;
/// * the builder error type;
/// * the `msg` method on the builder error type;
/// * the `builder` method on the struct on which `Builder` is derived.
///
/// So, this will compile:
///
/// ```
/// mod process {
///     #[derive(derive_builder::Builder, Debug)]
///     pub struct Command {
///         executable: String,
///         #[builder(each = "arg")]
///         args: Vec<String>,
///         current_dir: Option<String>,
///     }
/// }
///
/// let _ = process::Command::builder()
///     .executable("cargo".to_owned())
///     .build()
///     .unwrap();
/// ```
///
/// but this will not, because the generated struct
/// `CommandBuilder` is private:
///
/// ```compile_fail
/// mod process {
///     #[derive(derive_builder::Builder, Debug)]
///     struct Command {
///         _executable: String,
///         #[builder(each = "arg")]
///         _args: Vec<String>,
///         _current_dir: Option<String>,
///     }
/// }
///
/// use process::CommandBuilder;
/// ```
#[proc_macro_derive(Builder, attributes(builder))]
pub fn derive(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    match convert_input_to_output(&input) {
        Ok(stream) => stream,
        Err(err) => err.to_compile_error().into(),
    }
}

fn convert_input_to_output(input: &DeriveInput) -> Result<TokenStream, Error> {
    check_input_is_not_generic(input)?;

    let data_struct = get_data_struct(input)?;

    let vis = &input.vis;
    let caller_ty = &input.ident;

    let builder_ty = format_ident!("{}Builder", caller_ty);
    let builder_err_ty = format_ident!("{}Err", builder_ty);

    let fields_data = get_fields_data(data_struct)?;

    let builder_fields = get_builder_fields(&fields_data);
    let builder_setter_methods = get_builder_setter_methods(&fields_data, caller_ty, vis);
    let caller_ty_field_assignments =
        get_caller_ty_field_assignments(&fields_data, &builder_err_ty);
    let builder_ty_field_assignments = get_builder_ty_field_assignments(&fields_data);

    let builder_err_ty_doc_string =
        format!("Error type returned by the `build()` method on `{builder_ty}`.");

    let builder_ty_doc_string =
        format!("Builder type used to construct an instance of `{caller_ty}`.");

    let build_method_doc_string = format!(
        "Attempts to build an instance of `{caller_ty}`.\n\
        # Errors\n\
        Returns an error if any required setter was not called."
    );

    let builder_method_doc_string =
        format!("Returns a builder type used to construct an instance of `{caller_ty}`.");

    let output = quote! {

        #[doc = #builder_err_ty_doc_string]
        #[derive(::std::fmt::Debug)]
        #vis struct #builder_err_ty {
            msg: ::std::string::String,
        }

        impl #builder_err_ty {
            fn new(msg: &str) -> #builder_err_ty {
                #builder_err_ty{
                    msg: ::std::string::String::from(msg),
                }
            }

            /// Returns the contained error message.
            #[must_use]
            #vis fn msg(&self) -> &str {
                self.msg.as_str()
            }
        }

        impl ::std::fmt::Display for #builder_err_ty {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "{}", self.msg)
            }
        }

        impl ::std::error::Error for #builder_err_ty {}

        #[doc = #builder_ty_doc_string]
        #vis struct #builder_ty {
            #(#builder_fields)*
        }

        impl #builder_ty {
            #(#builder_setter_methods)*

            #[doc = #build_method_doc_string]
            #vis fn build(&mut self) -> ::std::result::Result<#caller_ty, #builder_err_ty> {
                ::std::result::Result::Ok(
                    #caller_ty{
                        #(#caller_ty_field_assignments)*
                    }
                )
            }
        }

        impl #caller_ty {
            #[doc = #builder_method_doc_string]
            #[must_use]
            #vis fn builder() -> #builder_ty {
                #builder_ty {
                    #(#builder_ty_field_assignments)*
                }
            }
        }
    }
    .into();

    Ok(output)
}

fn check_input_is_not_generic(input: &DeriveInput) -> Result<(), Error> {
    if input.generics.params.is_empty() {
        Ok(())
    } else {
        Err(Error::new_spanned(
            &input.generics,
            "expected struct without generic type parameters",
        ))
    }
}

fn get_data_struct(input: &DeriveInput) -> Result<&DataStruct, Error> {
    match &input.data {
        Data::Struct(data) => Ok(data),
        Data::Enum(data) => Err(Error::new(
            data.enum_token.span,
            "expected struct, found `enum`",
        )),
        Data::Union(data) => Err(Error::new(
            data.union_token.span,
            "expected struct, found `union`",
        )),
    }
}

fn get_fields_data(data_struct: &DataStruct) -> Result<Vec<FieldData<'_>>, Error> {
    let mut field_to_field_data = FieldToFieldData::<'_>::new(&data_struct.fields);

    data_struct
        .fields
        .iter()
        .map(|f| field_to_field_data.convert(f))
        .collect::<Result<Vec<_>, _>>()
}

fn get_builder_fields<'a>(
    fields_data: &'a [FieldData<'_>],
) -> impl Iterator<Item = impl ToTokens> + 'a {
    fields_data.iter().map(|fd| {
        let ident = fd.ident;
        let ty = fd.ty;

        if let TypeKind::Repeated { .. } = fd.kind {
            quote! { #ident: ::std::vec::Vec<#ty>, }
        } else {
            quote! { #ident: ::std::option::Option<#ty>, }
        }
    })
}

fn get_builder_setter_methods<'a>(
    fields_data: &'a [FieldData<'_>],
    caller_ty: &'a Ident,
    vis: &'a Visibility,
) -> impl Iterator<Item = impl ToTokens> + 'a {
    fields_data.iter().map(move |fd| {
        let ident = fd.ident;
        let ty = fd.ty;

        if let TypeKind::Repeated { ident: one_at_a_time_ident } = &fd.kind {
            let one_at_a_time_method_doc_string = format!(
                "Setter for the `{ident}` field of `{caller_ty}` that can append values to `{ident}`,\n\
                one at a time. It is optional to be called. If no setter is called for the `{ident}`\n\
                field, then the field stays empty."
            );

            let one_at_a_time_method = quote! {
                #[doc = #one_at_a_time_method_doc_string]
                #vis fn #one_at_a_time_ident(&mut self, #one_at_a_time_ident: #ty) -> &mut Self {
                    self.#ident.push(#one_at_a_time_ident);
                    self
                }
            };

            if one_at_a_time_ident == ident {
                one_at_a_time_method
            } else {
                let all_at_once_method_doc_string = format!(
                    "Setter for the `{ident}` field of `{caller_ty}` that can assign multiple values,\n\
                    all at once, overwriting the previous values. It is optional to be called.\n\
                    If no setter is called for the `{ident}` field, then the field stays empty."
                );

                quote! {
                    #one_at_a_time_method

                    #[doc = #all_at_once_method_doc_string]
                    #vis fn #ident(&mut self, #ident: ::std::vec::Vec<#ty>) -> &mut Self {
                        self.#ident = #ident;
                        self
                    }
                }
            }
        } else {
            let doc_string = if let TypeKind::Optional = &fd.kind {
                format!(
                    "Setter for the `{ident}` field of `{caller_ty}`, optional to be called.\n\
                    If this setter is not called, the field's value remains\n\
                    [`None`](https://doc.rust-lang.org/std/option/enum.Option.html#variant.None)."
                )
            } else {
                format!("Setter for the `{ident}` field of `{caller_ty}`, required to be called.")
            };

            quote! {
                #[doc = #doc_string]
                #vis fn #ident(&mut self, #ident: #ty) -> &mut Self {
                    self.#ident = ::std::option::Option::Some(#ident);
                    self
                }
            }
        }
    })
}

fn get_caller_ty_field_assignments<'a>(
    fields_data: &'a [FieldData<'_>],
    builder_err_ty: &'a Ident,
) -> impl Iterator<Item = impl ToTokens> + 'a {
    fields_data.iter().map(move |fd| {
        let ident = fd.ident;

        match fd.kind {
            TypeKind::Optional => {
                quote! {
                    #ident: self.#ident.take(),
                }
            }
            TypeKind::Repeated { .. } => {
                quote! {
                    #ident: ::std::mem::take(&mut self.#ident),
                }
            }
            TypeKind::Regular => {
                quote! {
                    #ident:
                        self
                            .#ident
                            .take()
                            .ok_or(
                                <#builder_err_ty>::new(
                                    ::std::concat!(
                                        "field `",
                                        ::std::stringify!(#ident),
                                        "` was not set",
                                    )
                                )
                            )?,
                }
            }
        }
    })
}

fn get_builder_ty_field_assignments<'a>(
    fields_data: &'a [FieldData<'_>],
) -> impl Iterator<Item = impl ToTokens> + 'a {
    fields_data.iter().map(|fd| {
        let ident = fd.ident;

        if let TypeKind::Repeated { .. } = fd.kind {
            quote! {
                #ident: ::std::vec::Vec::new(),
            }
        } else {
            quote! {
                #ident: ::std::option::Option::None,
            }
        }
    })
}

enum TypeKind {
    Regular,
    Optional,
    Repeated { ident: Ident },
}

struct FieldData<'a> {
    ident: &'a Ident,
    ty: &'a Type,
    kind: TypeKind,
}

struct FieldToFieldData<'a> {
    all_fields: &'a Fields,
    repeated_builder_method_raw_idents: HashSet<String>,
}

impl FieldToFieldData<'_> {
    fn new(all_fields: &Fields) -> FieldToFieldData<'_> {
        FieldToFieldData {
            all_fields,
            repeated_builder_method_raw_idents: HashSet::new(),
        }
    }

    fn convert<'a>(&mut self, field: &'a Field) -> Result<FieldData<'a>, Error> {
        let (ty, kind) = self.get_ty_and_kind(field)?;

        Ok(FieldData {
            ident: field.ident.as_ref().ok_or(Error::new(
                self.all_fields.span(),
                "expected struct with named fields, found tuple-struct",
            ))?,
            ty,
            kind,
        })
    }

    fn get_ty_and_kind<'a>(&mut self, field: &'a Field) -> Result<(&'a Type, TypeKind), Error> {
        if let Some(ident) = get_repeated_builder_method_ident(field)? {
            if self
                .repeated_builder_method_raw_idents
                .insert(ident.to_string())
            {
                let ty = get_concrete_ty_from_vec_ty(&field.ty)
                    .ok_or(Error::new_spanned(&field.ty, "expected standard Vec"))?;

                Ok((ty, TypeKind::Repeated { ident }))
            } else {
                Err(Error::new(
                    ident.span(),
                    format!("identifier `{ident}` is duplicated"),
                ))
            }
        } else if let Some(ty) = get_concrete_ty_from_option_ty(&field.ty) {
            Ok((ty, TypeKind::Optional))
        } else {
            Ok((&field.ty, TypeKind::Regular))
        }
    }
}

fn get_repeated_builder_method_ident(field: &Field) -> Result<Option<Ident>, Error> {
    let invalid_attr_err_msg = r#"expected `builder(each = "...")`"#;
    let multiple_attr_err_msg = "multiple `builder` attributes on the same field";

    let mut builder_attrs = field.attrs.iter().filter_map(|attr| match &attr.meta {
        Meta::List(l) if is_builder_attribute(&l.path) => Some(Ok(attr)),
        Meta::NameValue(nv) if is_builder_attribute(&nv.path) => Some(Err((
            Error::new_spanned(&attr.meta, invalid_attr_err_msg),
            attr,
        ))),
        Meta::Path(p) if is_builder_attribute(p) => {
            Some(Err((Error::new(p.span(), invalid_attr_err_msg), attr)))
        }
        _ => None,
    });

    match (builder_attrs.next(), builder_attrs.next()) {
        (None, None) => Ok(None),
        (Some(Ok(attr)), None) => {
            let mut ident = None;
            attr.parse_nested_meta(|meta| {
                if meta.path.is_ident("each") {
                    ident = Some(meta.value()?.parse::<LitStr>()?.parse()?);
                    Ok(())
                } else {
                    Err(Error::new_spanned(&attr.meta, invalid_attr_err_msg))
                }
            })?;

            Ok(ident)
        }
        (Some(Err((e, _))), None) => Err(e),
        (_, Some(Ok(attr) | Err((_, attr)))) => {
            Err(Error::new_spanned(attr, multiple_attr_err_msg))
        }
    }
}

fn is_builder_attribute(path: &Path) -> bool {
    path.is_ident("builder")
}

fn get_concrete_ty_from_option_ty(ty: &Type) -> Option<&Type> {
    get_concrete_ty(&["std", "option", "Option"], ty)
}

fn get_concrete_ty_from_vec_ty(ty: &Type) -> Option<&Type> {
    get_concrete_ty(&["std", "vec", "Vec"], ty)
}

fn get_concrete_ty<'a>(raw_path: &[&str], ty: &'a Type) -> Option<&'a Type> {
    Some(ty)
        .and_then(|ty| {
            if let Type::Path(path) = ty {
                Some(path)
            } else {
                None
            }
        })
        .and_then(|path| {
            if path.qself.is_none() {
                match path.path.leading_colon {
                    Some(_) if path.path.segments.len() == raw_path.len() => {
                        Some(&path.path.segments)
                    }
                    None if path.path.segments.len() <= raw_path.len() => Some(&path.path.segments),
                    _ => None,
                }
            } else {
                None
            }
        })
        .and_then(|segments| {
            let last_raw_segment = raw_path.last();
            let last_segment = segments.last();

            let valid_segment_count = raw_path
                .iter()
                .rev()
                .skip(1)
                .zip(segments.iter().rev().skip(1))
                .take_while(|(raw_segment, segment)| {
                    segment.ident == raw_segment && segment.arguments.is_empty()
                })
                .count();

            match (last_raw_segment, last_segment) {
                (Some(last_raw_segment), Some(last_segment))
                    if valid_segment_count == segments.len() - 1 =>
                {
                    Some((last_raw_segment, last_segment))
                }
                _ => None,
            }
        })
        .and_then(
            |(last_raw_segment, last_segment)| match &last_segment.arguments {
                PathArguments::AngleBracketed(args) if last_segment.ident == last_raw_segment => {
                    Some(args.args.iter())
                }
                _ => None,
            },
        )
        .and_then(|mut args| {
            if let (Some(GenericArgument::Type(ty)), None) = (args.next(), args.next()) {
                Some(ty)
            } else {
                None
            }
        })
}
